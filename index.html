<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AXIO/1 2025</title>
    <style>
        body {
            margin: 0;
            height: 200vh; /* Make the page scrollable */
            overflow-x: hidden;
            font-family: Arial, sans-serif;
            color: Black;
            background-color: #EFEFFF;
        }

        /* Fixed Canvas Background */
        .canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: -1; /* Always behind other content */
        }

        /* Content on top */
        .content {
            position: relative;
            z-index: 1;
            padding: 50px;
        }
    </style>
</head>
<body>

    <div class="canvas-container"></div>

    <div class="content">

<aside>
        <H1>AXIO/1</h1>
        <h3>Artificial Experienced Intelligent Ontology v10.0 (2025)</h3>
        <div>GroupoÑ—d Infinity fibrational type systems for
                 mathematical representation, certification (theorem proving),
                 with extraction to verified interpreter and its runtime.
        </div>
        <div>
<ul>
  <li>Ğ£ĞºÑ€Ğ°Ñ—Ğ½ÑÑŒĞºĞ¾Ñ: Ğ¨Ñ‚ÑƒÑ‡Ğ½Ğ° Ğ”Ğ¾ÑĞ²Ñ–Ğ´Ñ‡ĞµĞ½Ğ° Ğ†Ğ½Ñ‚ĞµĞ»ĞµĞºÑ‚ÑƒĞ°Ğ»ÑŒĞ½Ğ° ĞĞ½Ñ‚Ğ¾Ğ»Ğ¾Ğ³Ñ–Ñ</li>
  <li>Ğ¢Ğ¸Ğ±ĞµÑ‚ÑÑŒĞºĞ¾Ñ: à½–à½Ÿà½¼à¼‹à½–à½€à½¼à½‘à¼‹à½€à¾±à½²à¼‹à½‰à½˜à½¦à¼‹à½¡à½¼à½‘à¼‹à½”à½ à½²à¼‹à½¢à½²à½‚à¼‹à½”à½ à½²à¼‹à½„à½¼à¼‹à½–à½¼à¼‹à½£à½´à½‚à½¦à¼ (bzo bkod kyi nyams yod pa'i rig pa'i ngo bo lugs)</li>
</ul>
        </div>

            <div>2015&mdash;2025 &copy; <a href="https://5ht.co/license/">DHARMA LICENSE</a>
            <br><br></div>
</aside>
<main>
    <section>

<h2>Table of Contents (à½‘à½€à½¢à¼‹à½†à½‚ dkar chag)</h2>
<ul>
    <li>Introduction</li>
    <li>Process</li>
    <li>Components</li>
    <li>Operators</li>
    <li>Refinments</li>
    <li>Goals</li>
    <li>Runtime Languages</li>
    <li>Higher Languages</li>
    <li>Total Verification of Mathematics</li>
</ul>

<h2>1. Introduction (à½„à½¼à¼‹à½¦à¾¤à¾²à½¼à½‘ ngo sprod)</h2>
<p>The <strong>AXIO/1 Framework</strong> is a layered system for <strong>infinite reasoning</strong>, structured into:</p>
<ul>
    <li><strong>Runtime Languages</strong>: Execute computations and manage concurrency.</li>
    <li><strong>Higher Languages</strong>: Handle theorem proving and formal verification.</li>
</ul>
<p>This framework operates as a <strong>cyclic, iterative system</strong> for formal reasoning,
   where an <strong>operator</strong> (human, AI, or hybrid) directs a process that continuously refines itself.</p>

<h2>2. Process (à½£à½¦à¼‹à½€ las ka)</h2>
<p>AXIO/1 follows a structured flow:</p>
<ol>
    <li><strong>Conditions</strong>: Foundational elements (Axioms, Definitions, Types, Propositions, Syntax).</li>
    <li><strong>Environment</strong>: The structured setting (Model, Consistency, Completeness, Library).</li>
    <li><strong>Thinking</strong>: Reasoning mechanisms (Hypotheses, Computation, Deduction, Conjecture, Inference Rules, General Induction).</li>
    <li><strong>Fruit</strong>: Logical results (Proof, Judgment, Theorem).</li>
    <li><strong>Insight</strong>: Higher-level understanding (Semantics, Categorical Frameworks, Abstraction).</li>
</ol>

<h2>3. Components (à½†à¼‹à½¤à½¦ cha shas)</h2>

<h3>Condition (C) à½¢à¾à¾±à½ºà½“ Ğ£Ğ¼Ğ¾Ğ²Ğ° rkyen</h3>
<code>
    C = (A, D, T, P, X)
</code>
<ul>
    <li><strong>Axioms (A)</strong>: Fundamental truths.</li>
    <li><strong>Definitions (D)</strong>: Precise descriptions of entities.</li>
    <li><strong>Types (T)</strong>: Categorization of objects.</li>
    <li><strong>Syntax (X)</strong>: Structural rules.</li>
</ul>

<h3>Environment (E) à½à½¼à½¢à¼‹à½¡à½´à½‚ Ğ¡ĞµÑ€ĞµĞ´Ğ¾Ğ²Ğ¸Ñ‰Ğµ khor yug </h3>
<code>
    E = (M, C, K, L)
</code>
<ul>
    <li><strong>Model (M)</strong>: Formal representation of the system.</li>
    <li><strong>Consistency (C)</strong>: No contradictions within the system.</li>
    <li><strong>Completeness (K)</strong>: The extent to which all truths can be derived.</li>
    <li><strong>Library (L)</strong>: Repository of known results.</li>
</ul>

<h3>Reason (T) à½¢à¾’à¾±à½´ ĞŸÑ€Ğ¸Ñ‡Ğ¸Ğ½Ğ° rgyu </h3>
<code>
    T = (J, H, C, D, G)
</code>
<ul>
    <li><strong>Judgment (J)</strong>: Logical assertions.</li>
    <li><strong>Hypotheses (H)</strong>: Presupposition, Assumption, Supposition, Proposition.</li>
    <li><strong>Computation (C)</strong>: Lambda Calculus, Pi-Calculus.</li>
    <li><strong>Deduction (D)</strong>: Inference Rules, General Induction.</li>
    <li><strong>Conjecture/Assertion (G)</strong>: Formulation of potential truths.</li>
</ul>

<h3>Fruit (F) à½ à½–à¾²à½¦à¼‹à½–à½´ ĞŸĞ»Ñ–Ğ´ 'bras bu</h3>
<code>
    F = (âŠ¢,Î˜)
</code>
<ul>
    <li><strong>Proof</strong> âŠ¢ Verified propositions.</li>
    <li><strong>Theorem</strong> Î˜ Established truths.</li>
</ul>

<h3>Insight (I) à½£à¾Ÿà¼‹à½–à½ à½²à¼‹à½¤à½ºà½¦à¼‹à½” lta ba'i shes pa</h3>
<code>
    I = (S, C, A)
</code>
<ul>
    <li><strong>Semantics</strong> Î£: Meaning assignment.</li>
    <li><strong>Categorical Frameworks </strong> C: High-level abstractions..</li>
    <li><strong>Abstraction</strong> A: Generalization of concepts.</li>
</ul>

<h2>3. Operators (à½–à½€à½¼à½£à¼‹à½¦à¾¤à¾±à½¼à½‘à¼‹à½” bkol spyod pa) </h2>
<p>Three types of operators drive the system:</p>
<ul>
    <li><strong>Human</strong>: Chooses propositions, interprets insights, and guides conjectures.</li>
    <li><strong>Machine</strong>: Automates computations, checks consistency, and suggests hypotheses.</li>
    <li><strong>Hybrid</strong>: Human sets goals, machine executes reasoning steps.</li>
</ul>

<h2>4. Refinements (à½£à½ºà½‚à½¦à¼‹à½–à½…à½¼à½¦ legs bcos) </h2>
<p>Ensuring correctness and progression:</p>
<ul>
    <li><strong>Infinite Thinking</strong>: Achieved via iteration <code>Sâ‚™ â†’ âˆ</code>.</li>
    <li><strong>Finite Steps</strong>: Each step is discrete, <code>Sâ‚™ â†’ Sâ‚™â‚Šâ‚</code>.</li>
    <li><strong>Operator-Driven</strong>: The direction of reasoning is controlled by <code>O</code>.</li>
</ul>

<p>The cycle repeats indefinitely, refining knowledge.</p>
<code>
    Sâ‚€ â†’ Sâ‚ â†’ Sâ‚‚ â†’ ... â†’ Sâ‚™ â†’ Sâ‚™â‚Šâ‚ â†’ ...
</code>
<p>Where:</p>
<ul>
    <li><code>Sâ‚™</code> is a finite reasoning step.</li>
    <li><code>Sâ‚™â‚Šâ‚</code> builds upon <code>Sâ‚™</code>, ensuring refinement.</li>
    <li><strong>Limit process</strong>: <code>lim (n â†’ âˆ) Sâ‚™</code> represents <strong>infinite reasoning</strong>.</li>
</ul>

<h2>5. Design Goals (à½‘à½˜à½²à½‚à½¦à¼‹à½¡à½´à½£ dmigs yul)</h2>
<ul>
    <li><strong>Runtime Languages</strong>: Handle computation and concurrency.</li>
    <li><strong>Higher Languages</strong>: Ensure theorem proving and soundness.</li>
    <li><strong>Infinite Thinking</strong>: Achieved via refinements cycles.</li>
    <li><strong>Operator-Driven</strong>: Collaboration between humans and machines.</li>
</ul>

    </section>
    <section>
        <hr>
    </section>
    <section>
        <p>Verified Lambda Interpreter and Concurrent Parallel Matrix Runtime.
           Joe, Bob, and Alice languages share the same Standard ML like BNF grammar.</p>
    </section>
    <section>
        <a name=Joe></a>
        <h3><a href="https://github.com/groupoid/joe">Joe</a></h3>
         <p><b style="sel">Joe</b> is a certified bytecode stack interpreter and Intel/ARM code compiler.</p>
         <P>[1] â€” MinCaml<br>
            [2] â€” CoqASM<br>
            [3] â€” Verified LISP Interpreter<br>
            [4] â€” Kind<br>
         </p>
        <figure><pre>
fun a (0, n) = n + 1
  | a (m, 0) = a (m - 1, 1)
  | a (m, n) = a (m - 1, a (m, n - 1))
        </pre></figure>
    </section>
    <section>
        <a name=Bob></a>
        <h3><a href="https://github.com/o83/n2o">Bob</a></h3>
         <p><b style="sel">Bob</b> is a parallel concurrent non-blocking
            zero-copy run-time with CAS cursors [4,5].</p>
         <P>[5] â€” Kernel<br>
            [6] â€” Pony<br>
            [7] â€” Erlang<br></p>
        <figure><pre>
fun proc =
let val p0 = pub(0,8)
    val s1 = sub(0,p0)
    val s2 = sub(0,p0)
 in send(p0,11);
    send(p0,12);
    [ receive(s1);
      receive(s2);
      receive(s1);
      receive(s2)
    ]
    end
        </pre></figure>
    </section>
    <section>
        <a name=Alice></a>
        <h3><a href="https://tonpa.guru/stream/2023/2023-09-25%20Formal%20Tensor.htm">Alice</a></h3>
         <p><b style="sel">Alice</b> is a linear types calculus
            with partial fractions [6] for BLAS level 3 programming.</p>
         <P>[8] â€” NumLin<br> </p>
   <figure><pre>
fun simpleConvolution (i n: int) (x0: float) (write w: vector float)
  : vector float
  = begin
      if n = i then result.emit(write),
      a = [w0,w1,w2] = w.get(0,3),
      b = [x0,x1,x2] = [ x0 | write.get(i,2) ],
      write.set(i, Dotp(a,b)),
      simpleConvolution((i + 1),n,x1,write,w)
    end
     </pre></figure>
    </section>
    <section>
        <hr>
    </section>
    <section>
        <p>Sound and Consistent Predicative Formal Languages.
           Henk, Per, Anders, Dan languages share the same Lean like BNF grammar.</p>
    </section>
    <section>
        <a name=Henk></a>
        <h3><a href="https://github.com/groupoid/henk">Henk</a></h3>
        <p><b style="sel">Henk</b> is a Pure Type System (PTS-91) in
             the style of Coquand/Huet Calculus of Inductive Constructions (CoC-88)
             with infinite numbere of universes. Henk also supports AUTOMATH syntax (AUT-68).</p>
        <p>
           AUT-68 â€” AUTOMATH<br>
           CoC-88 â€” Calculus of Constructions<br>
           PTS-91 â€” Pure Type System (Î )<br>
        </p>

        <figure><pre>
def N := Î  (A : U), (A â†’ A) â†’ A â†’ A
def zero : N := Î» (A : U) (S : A â†’ A) (Z : A), Z
def succ : N -> N := Î» (n : N) (A : U) (S : A â†’ A) (Z : A), S (n A S Z)
def plus (m n : N) : N := Î» (A : U) (S : A â†’ A) (Z : A), m A S (n A S Z)
def mult (m n : N) : N := Î» (A : U) (S : A â†’ A) (Z : A), m A (n A S) Z
def pow (m n : N) : N := Î» (A : U) (S : A â†’ A) (Z : A), n (A â†’ A) (m A) S Z
        </pre></figure>

    </section>
    <section>
        <a name=Per></a>
        <h3><a href="https://github.com/groupoid/per">Per</a></h3>
        <p><b style="sel">Per</b> is a Î Î£ (MLTT-72) prover with Calculus of
           Inductive Constructions and idenitity types (MLTT-75). The natural
           extension of CoC to CIC was done by Frank Pfenning and Christine Paulin (IND-89).</p>
        <p>
           Mini-TT â€” OCaml implementation<br>
           MLTT-72 â€” Pi, Sigma<br>
           MLTT-75 â€” Pi, Sigma, Id<br>
           MLTT-80 â€” 0, 1, 2, W, Pi, Sigma, Id<br>
           PP-89 â€” Inductively Defined Types<br>
           CIC-2015 â€” Calculus of Inductive Constructiions<br>
        </p>
        <figure><pre>
def empty      : U := inductive { }
def LÂ¹ (A : U) : U := inductive { nil | cons (head: A) (tail: LÂ¹ A) }
def SÂ¹         : U := inductive { base | loop : Equ SÂ¹ base base }

def quot (A: U) (R : A -> A -> U) : U
 := inductive { quotient (a: A)
              | identification (a b: A) (r: R a b)
              : Equ (quot A R) (quotient a) (quotient b)
              }
        </pre></figure>
    </section>
    <section>
        <a name=Anders></a>
        <h3><a href="https://github.com/groupoid/anders">Anders</a></h3>
        <p><b style="sel">Anders</b> is a Homotopy Type System (HTS-2013)
           with Strict Equality and Cubical Agda (CCHM-2016) primitives.</p>
        <p>
           HTS-2013 â€” Homotopy Type System<br>
           BCH-2014 â€” Cubical Sets<br>
           CCHM-2015 â€” Cubical Type System<br>
           OP-2016 â€” Topos Axioms<br>
           CHM-2017 â€” Huber Equations<br>
           VMA-2017 â€” Cubical Agda<br>
        </p>
        <figure><pre>
def idfun  (A : U) : A â†’ A := Î» (a : A), a
def idfunâ€² (A : U) : A â†’ A := transp (&lt;i> A) 0
def idfunâ€³ (A : U) : A â†’ A := Î» (a : A), hcomp A 0 (Î» (i : I), []) a
def isFiberBundle (B: U) (p: B â†’ U) (F: U): U
 := Î£ (v: U) (w: surjective v B), (Î  (x: v), PathP (&lt;_>U) (p (w.1 x)) F)
def ~~ (X : U) (a xâ€² : X) : U := Path (â„‘ X) (Î¹ X a) (Î¹ X xâ€²)
def ğ”» (X : U) (a : X) : U := Î£ (xâ€² : X), ~~ X a xâ€²
def unitDisc (X : U) (x : â„‘ X) : U := Î£ (xâ€² : X), Path (â„‘ X) x (Î¹ X xâ€²)
def starDisc (X : U) (x : X) : ğ”» X x := (x, idp (â„‘ X) (Î¹ X x))
def Tâˆ (A : U) : U := Î£ (a : A), ğ”» A a
def inf-prox-ap (X Y : U) (f : X â†’ Y) (x xâ€² : X) (p : ~~ X x xâ€²)
  : ~~ Y (f x) (f xâ€²) := &lt;i> â„‘-app X Y f (p @ i)
def d (X Y : U) (f : X â†’ Y) (x : X) (Îµ : ğ”» X x) : ğ”» Y (f x)
 := (f Îµ.1, inf-prox-ap X Y f x Îµ.1 Îµ.2)
def Tâˆ-map (X Y : U) (f : X â†’ Y) (Ï„ : Tâˆ X) : Tâˆ Y
 := (f Ï„.1, d X Y f Ï„.1 Ï„.2)
def is-homogeneous (A : U)
 := Î£ (e : A) (t : A â†’ equiv A A),
    Î  (x : A), Path A ((t x).1 e) x
         </pre></figure>

    </section>
    <section>
        <a name=Daniel></a>
        <h3><a href="https://github.com/groupoid/dan">Dan</a></h3>
        <p><b style="sel">Dan</b> is a simplicial CCHM-based verification system with
           Simplicial, Simplex, Chain, Monoid, Category, Group primitives built into the type checker core.
           Dan is new Rzk/GAP replacement with Kan, Rezk and Segal simplicial
           modes for computable âˆ-categories.
        </p>
        <p>
           R-HoTT â€” Rezk Infinity Categories<br>
           Hopf-HoTT â€” Hopf Fibrations, Stable Spherical Homotopy Groups<br>
        </p>
        <figure><pre>
def path_z2_category : Category
 := ĞŸ (x y : Simplex),
      (f g h : Simplex),
      (z2 : Group(ĞŸ (e a : Simplex), aÂ² = e âŠ¢ 1 (a | aÂ² = e))),
      f âˆ˜ g = h
    âŠ¢ 2 (x y | f g h | f âˆ˜ g = h)

def z3 : Group
 := ĞŸ (e a : Simplex),
      aÂ³ = e
    âŠ¢ 1 (a | aÂ³ = e)

def MÃ¶bius : Simplex
 := ĞŸ (a b c : Simplex),
      (bc ac : Simplex), ab = bc âˆ˜ ac
    âŠ¢ 2 (a b c | bc ac ab)
         </pre></figure>

    </section>
    <section>
        <a name=Jack></a>
        <h3><a href="https://github.com/groupoid/jack">Jack</a></h3>
        <p><b style="sel">Jack</b> is a Minimal Framework for Homotopy Groups of Spheres
           which encompasses unstable homotopy, stable homotopy (e.g., Ï€â‚€^S(Sâ°) = â„¤),
           and chromatic phenomena (e.g., H^*(RP^2), spectral sequences),
           inspired by Morava's chromatic vision. It features HopfFibâ¿ (n=1,2,3,4),
           Susp(A), Truncâ¿(A), â„•, â„•âˆ, Î (x:A).B, Î£(x:A).B, Id_A(u, v), Spec, Ï€â‚™^S(A),
           Sâ°[p], Group, A âˆ§ B, [A, B], Hâ¿(X; G), G âŠ— H, SS(E, r). It has
           Sâ¿, Ï€â‚™(Sáµ), K(G, n), Cohomology Rings, Chromatic Towers as derivables.
        </p>

        <a name=Urs></a>
        <h3><a href="https://github.com/groupoid/urs">Urs</a></h3>
        <p><b style="sel">Urs</b> is a Framework for Supergeometry in Cohesive Topos.
           It features Graded Universes, Graded Tensor, Group Action, Super Type Theory: Uáµáµ¢| ğ–˜ A | ğ”¾ â†’ A,
           Super Modality: Î“ âŠ¢ A : Uáµ¢^g â†’ Î“ âŠ¢ ğ–˜ A : Uáµ¢^g, Cohesive Type Theory: âˆ£ Êƒ âˆ£ â™­ âˆ£ â™¯ âˆ£ â„‘ | & | â„œ .</P>

        <a name=Julius></a>
        <h3><a href="https://github.com/groupoid/julius">Julius</a></h3>
        <p><b style="sel">Julius</b> is a type system for Dedekind Reals, Cuts and Real Analysis.
           It features â„, â„š, âŠ¢ (ğ¿, ğ‘ˆ) : â„, where ğ¿, ğ‘ˆ : â„š â†’ Prop, âˆ€ ğ‘ < ğ‘Ÿ â†’ ğ¿(ğ‘) âˆ¨ ğ‘ˆ(ğ‘Ÿ).</P>

        <a name=Ernst></a>
        <h3><a href="https://github.com/groupoid/ernst">Ernst</a></h3>
	<p><b style="sel">Ernst</b> is a type system for  ZFC LEM theories.
            It features: ğ‘‰, Pow(ğ´), ğ‘¥ âˆˆ ğ´, ğ´ âŠ† ğµ; LEM: âŠ¢ ğ‘ƒ âˆ¨ Â¬ğ‘ƒ for Classical Logic Support.</p>

        <a name=Paul></a>
        <h3><a href="https://github.com/groupoid/paul">Paul</a></h3>
	<p><b style="sel">Paul</b> is a type system for Forced Cardinals.
            It features: âŠ¢ ğœ… : Card, inaccessible(ğœ…), measurable(ğœ…), Force(ğ‘ƒ, ğº) : ğ‘‰ â†’ ğ‘‰, ğ‘ âŠ© ğœ™,
            Generic filter ğº over a poset ğ‘ƒ, yielding a new model ğ‘‰[ğº], allowing for
            adjoin reals and control cardinalities or axioms.</p>

        <a name=Fabien></a>
        <h3><a href="https://github.com/groupoid/fabien">Fabien</a></h3>
	<p><b style="sel">Fabien</b> is a Motivic A^1-Homotopy Theory.
            It featues Î ,Î£,Path,ğ‘˜:ğ‘ˆ,0_ğ‘˜,1_ğ‘˜,point_ğ‘˜,ğ´^1:U,point:ğ‘˜â†’ğ´^1., A^1-contr,
            ğ¿_{A^1}:Uâ†’ğ‘ˆ, ğœ‚_{A^1}, rec_{A^1}, n-Trunc, ğ‘, Suspension,S^{1,1}, Nisnevich Cover. It derives all
            structural theorems of A^1-Homotopy Theoryâ€”such as A^1-connectivity (XÃ—A^1)â‰…Ï€_n(A^1),
            contractibility of ğ´^1, and unstable connectivity â€” while providing a foundation
            for stable A^1-homotopy via suspensions and motivic spheres. Explicitly
            supporting Nisnevich descent, aligning L_{A^1} with sheaf-like properties,
            while keeping k as a placeholder.</p>

        <figure><pre>
def k : U
def 0_k : k
def 1_k : k

def A1 : U := inductive { point : k â†’ A1 }
def 0_A1 : A1 := A1.point 0_k
def 1_A1 : A1 := A1.point 1_k
def A^1-contr (a : A1) : Path A1 a 0_A1 := &lt;i> comp A1 [j : I] a (i âˆ§ j) 0_A1

def L_A1 (X : U) : U := (i : I) â†’ X
def isA1Local (Y : U) : U
 := isEquiv (Î» (y : Y) (a : A1). y : Y Ã— A1 â†’ Y)

def eta_A1 (X : U) (x : X) : L_A1 X := &lt;i> x
def rec_A1 (X Y : U) (f : X â†’ Y) (loc : isA1Local Y) : L_A1 X â†’ Y
 := Î» z => comp Y [i : I] (f (z i)) (f (z 0))

def S11 : U
 := inductive { base : S11
              | loop : A1 â†’ Path S11 base base
              | zero : Path S11 (loop 0_A1) (refl base)
              }

def NisCover (X : U) : U
 := inductive {
              | triv : X â†’ NisCover X
              | cover : (U : U) â†’ (f : U â†’ X) â†’ isNisCover f â†’ NisCover X
              }

def isSurjective (X Y : U) (f : X â†’ Y) : Type fibrant
 := âˆ€ (y : Y), âˆƒ (x : X), Path Y (f x) y

def isNisCover (X U : U) (f : U â†’ X) : U
 := isSurjective f

def rec_NisCover
    (X : U) (C : NisCover X â†’ U)
    (t : âˆ€ (x : X), C (NisCover.triv x)) 
    (d : âˆ€ (U : U) (f : U â†’ X) (h : isNisCover f), C (NisCover.cover U f h))
    (c : NisCover X) : C c
 := match c with
    | NisCover.triv x => t x
    | NisCover.cover U f h => d U f h

def L_A1-NC (X : U) : U
 := Î£ (x : (i : I) â†’ X),
    âˆ€ (c : NisCover X),
    Path X (rec_NisCover (Î» x => x) (Î» U f h => f (h x).1) c) (x 0)

def isA1Local-NC (X : U) : U
 := âˆ€ (c : NisCover X),
    isEquiv (rec_NisCover (Î» x => x) (Î» U f h => f) c)

def eta_A1 (X : U) (x : X) : L_A1-NC X
 := ((&lt;i> x), Î» c => refl x)

         </pre></figure>


    </section>
    <section>
        <H2>Total Verification of Mathematics</H2>

	<p><b>Axiomatic Extended Integrated Ordered System for Infinite Structures (AXIOSIS)</b>
           is a novel type theory engineered to mechanically verify all existing
           theorems across mathematics, from classical analysis to modern set
           theory and homotopy. Building on top of advanced frameworks:</p>

<p><ul>
<li><b>Henk Barendregt</b> Type Theory for Pure Dependent Lambda Calculus,</li>
<li><b>Per Martin-LÃ¶f</b> Type Theory for Fibrational setting and inductive types,</li>
<li><b>Anders MÃ¶rtberg</b> Type Theory for CCHM/CHM/HTS bootstrap,</li>
<li><b>Dan Kan</b> Simplicial HoTT,</li>
<li><b>Jack Morava</b> Type Theory for Chromatic Homotopy Theory and K-Theory,</li>
<li><b>Urs Schreiber</b> Type Theory for Equivariant Supergeometry,</li>
<li><b>Fabien Morel</b> Type Theory for AÂ¹-homotopy theory,</li>
<li><b>Julius Dedekind</b> Type Theory for Reals,</li>
<li><b>Ernst Zermelo</b> Type Theory for ZFC with LEM, and</li>
<li><b>Paul Cohen</b> Type Theory for cardinals system incorporating large cardinals and forcing;</li></ul></p>

<p>this system synthesis unifies synthetic homotopy, stable homotopy spectra, cohesive geometry, real analysis,
and set-theoretic foundations into a single, computationally verifiable formalism. We demonstrate its
power through key theorems:</p>

<p><ul>
<li>Number Theory: Prime Number Theorem,</li>
<li>Fundamental Theorem of Calculus (Analysis),</li>
<li>Analysis: Lebesgue Dominated Convergence Theorem,</li>
<li>Topology: PoincarÃ© Conjecture (3D),</li>
<li>Algebra: Classification of Finite Simple Groups,</li>
<li>Set Theory: Independence of the Continuum Hypothesis (CH),</li>
<li>Category Theory: Adjoint Functor Theorem,</li>
<li>Homotopy Theory: Adams Conjecture (via K-theory),</li>
<li>Cohesive Homotopy Theory: Brouwer Fixed-Point Theorem,</li>
<li>Consistency of ZFC with Large Cardinals,</li>
<li>Fermatâ€™s Last Theorem,</li>
<li>Large Cardinal Theorem: Martinâ€™s Maximum;</li></ul>

<p>showcasing its ability to span algebraic, analytic, topological, and
foundational domains. The verification systems stands as a candidate for a universal mechanized mathematics platform,
rivaling systems like Cubical Type Theory while extending their scope.
The system achieves a landmark synthesis, unifying synthetic and classical mathematics in a mechanically
verifiable framework. Its type formersâ€”spanning simplicial âˆ-categories, stable spectra, cohesive modalities,
reals, ZFC, large cardinals, and forcing â€” cover all known mathematical domains as of 2025.</p>

        <a name=Mono></a>
        <h3>Monography as Introductory Course</h3>
        <ul><li>Published by Axiosis: <a href="https://axiosis.github.io/books/axio/axio.pdf">axiosis.github.io/books/axio/axio.pdf</a></li>
        <li>AXIO/AXIOSIS Github Organization: <a href="https://github.com/groupoid/">github.com/groupoid/</a></li></ul>
    </section>
    <section>
        <h3>LaTeX</h3>

<figure><pre>
$ cp *.ttf ~/.local/share/fonts
$ sudo apt install texlive-full
$ sudo fc-cache -f
$ fc-match Geometria
$ make
</pre></figure>

        <h3>Sole Copyright</h3>

        <p>Namdak Tonpa</p>

    <section>


</main>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });

        renderer.setSize(window.innerWidth, window.innerHeight);
        document.querySelector(".canvas-container").appendChild(renderer.domElement);

        const starGeometry = new THREE.BufferGeometry();
        const starCount = 1500;
        const starVertices = [];

        for (let i = 0; i < starCount; i++) {
            let x = (Math.random() - 0.5) * 1000;
            let y = (Math.random() - 0.5) * 1000;
            let z = (Math.random() - 0.5) * 1000;
            starVertices.push(x, y, z);
        }

        starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
        const starMaterial = new THREE.PointsMaterial({ color: 0xFFFFFF, size: 2 });
        const stars = new THREE.Points(starGeometry, starMaterial);
        scene.add(stars);
        camera.position.z = 300;

        function animate() {
            requestAnimationFrame(animate);
            stars.rotation.y += 0.001;
            renderer.render(scene, camera);
        }

        function onResize() {
            renderer.setSize(window.innerWidth, window.innerHeight);
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
        }

        window.addEventListener("resize", onResize);

        animate();
    </script>

</body>
</html>