<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AXIO/1 2025</title>
    <style>
        body {
            margin: 0;
            height: 200vh; /* Make the page scrollable */
            overflow-x: hidden;
            font-family: Arial, sans-serif;
            color: Black;
            background-color: #EFEFFF;
        }

        /* Fixed Canvas Background */
        .canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: -1; /* Always behind other content */
        }

        /* Content on top */
        .content {
            position: relative;
            z-index: 1;
            padding: 50px;
        }
    </style>
</head>
<body>

    <div class="canvas-container"></div>

    <div class="content">

<aside>
        <H1>AXIO/1</h1>
        <h3>Artificial Experienced Intelligent Ontology v10.0 (2025)</h3>
        <div>Groupo—ód Infinity fibrational type systems for
                 mathematical representation, certification (theorem proving),
                 with extraction to verified interpreter and its runtime.
        </div>
        <div>
<ul>
  <li>–£–∫—Ä–∞—ó–Ω—Å—å–∫–æ—é: –®—Ç—É—á–Ω–∞ –î–æ—Å–≤—ñ–¥—á–µ–Ω–∞ –Ü–Ω—Ç–µ–ª–µ–∫—Ç—É–∞–ª—å–Ω–∞ –û–Ω—Ç–æ–ª–æ–≥—ñ—è</li>
  <li>–¢–∏–±–µ—Ç—Å—å–∫–æ—é: ‡Ωñ‡Ωü‡Ωº‡ºã‡Ωñ‡ΩÄ‡Ωº‡Ωë‡ºã‡ΩÄ‡æ±‡Ω≤‡ºã‡Ωâ‡Ωò‡Ω¶‡ºã‡Ω°‡Ωº‡Ωë‡ºã‡Ωî‡Ω†‡Ω≤‡ºã‡Ω¢‡Ω≤‡ΩÇ‡ºã‡Ωî‡Ω†‡Ω≤‡ºã‡ΩÑ‡Ωº‡ºã‡Ωñ‡Ωº‡ºã‡Ω£‡Ω¥‡ΩÇ‡Ω¶‡ºç (bzo bkod kyi nyams yod pa'i rig pa'i ngo bo lugs)</li>
</ul>
        </div>

            <div>2015&mdash;2025 &copy; <a href="https://5ht.co/license/">DHARMA LICENSE</a>
            <br><br></div>
</aside>
<main>
    <section>

<h2>Table of Contents (‡Ωë‡ΩÄ‡Ω¢‡ºã‡ΩÜ‡ΩÇ dkar chag)</h2>
<ul>
    <li>Introduction</li>
    <li>Process</li>
    <li>Components</li>
    <li>Operators</li>
    <li>Refinments</li>
    <li>Goals</li>
    <li>Runtime Languages</li>
    <li>Higher Languages</li>
    <li>Total Verification of Mathematics</li>
</ul>

<h2>1. Introduction (‡ΩÑ‡Ωº‡ºã‡Ω¶‡æ§‡æ≤‡Ωº‡Ωë ngo sprod)</h2>
<p>The <strong>AXIO/1 Framework</strong> is a layered system for <strong>infinite reasoning</strong>, structured into:</p>
<ul>
    <li><strong>Runtime Languages</strong>: Execute computations and manage concurrency.</li>
    <li><strong>Higher Languages</strong>: Handle theorem proving and formal verification.</li>
</ul>
<p>This framework operates as a <strong>cyclic, iterative system</strong> for formal reasoning,
   where an <strong>operator</strong> (human, AI, or hybrid) directs a process that continuously refines itself.</p>

<h2>2. Process (‡Ω£‡Ω¶‡ºã‡ΩÄ las ka)</h2>
<p>AXIO/1 follows a structured flow:</p>
<ol>
    <li><strong>Conditions</strong>: Foundational elements (Axioms, Definitions, Types, Propositions, Syntax).</li>
    <li><strong>Environment</strong>: The structured setting (Model, Consistency, Completeness, Library).</li>
    <li><strong>Thinking</strong>: Reasoning mechanisms (Hypotheses, Computation, Deduction, Conjecture, Inference Rules, General Induction).</li>
    <li><strong>Fruit</strong>: Logical results (Proof, Judgment, Theorem).</li>
    <li><strong>Insight</strong>: Higher-level understanding (Semantics, Categorical Frameworks, Abstraction).</li>
</ol>

<h2>3. Components (‡ΩÜ‡ºã‡Ω§‡Ω¶ cha shas)</h2>

<h3>Condition (C) ‡Ω¢‡æê‡æ±‡Ω∫‡Ωì –£–º–æ–≤–∞ rkyen</h3>
<code>
    C = (A, D, T, P, X)
</code>
<ul>
    <li><strong>Axioms (A)</strong>: Fundamental truths.</li>
    <li><strong>Definitions (D)</strong>: Precise descriptions of entities.</li>
    <li><strong>Types (T)</strong>: Categorization of objects.</li>
    <li><strong>Syntax (X)</strong>: Structural rules.</li>
</ul>

<h3>Environment (E) ‡ΩÅ‡Ωº‡Ω¢‡ºã‡Ω°‡Ω¥‡ΩÇ –°–µ—Ä–µ–¥–æ–≤–∏—â–µ khor yug </h3>
<code>
    E = (M, C, K, L)
</code>
<ul>
    <li><strong>Model (M)</strong>: Formal representation of the system.</li>
    <li><strong>Consistency (C)</strong>: No contradictions within the system.</li>
    <li><strong>Completeness (K)</strong>: The extent to which all truths can be derived.</li>
    <li><strong>Library (L)</strong>: Repository of known results.</li>
</ul>

<h3>Reason (T) ‡Ω¢‡æí‡æ±‡Ω¥ –ü—Ä–∏—á–∏–Ω–∞ rgyu </h3>
<code>
    T = (J, H, C, D, G)
</code>
<ul>
    <li><strong>Judgment (J)</strong>: Logical assertions.</li>
    <li><strong>Hypotheses (H)</strong>: Presupposition, Assumption, Supposition, Proposition.</li>
    <li><strong>Computation (C)</strong>: Lambda Calculus, Pi-Calculus.</li>
    <li><strong>Deduction (D)</strong>: Inference Rules, General Induction.</li>
    <li><strong>Conjecture/Assertion (G)</strong>: Formulation of potential truths.</li>
</ul>

<h3>Fruit (F) ‡Ω†‡Ωñ‡æ≤‡Ω¶‡ºã‡Ωñ‡Ω¥ –ü–ª—ñ–¥ 'bras bu</h3>
<code>
    F = (‚ä¢,Œò)
</code>
<ul>
    <li><strong>Proof</strong> ‚ä¢ Verified propositions.</li>
    <li><strong>Theorem</strong> Œò Established truths.</li>
</ul>

<h3>Insight (I) ‡Ω£‡æü‡ºã‡Ωñ‡Ω†‡Ω≤‡ºã‡Ω§‡Ω∫‡Ω¶‡ºã‡Ωî lta ba'i shes pa</h3>
<code>
    I = (S, C, A)
</code>
<ul>
    <li><strong>Semantics</strong> Œ£: Meaning assignment.</li>
    <li><strong>Categorical Frameworks </strong> C: High-level abstractions..</li>
    <li><strong>Abstraction</strong> A: Generalization of concepts.</li>
</ul>

<h2>3. Operators (‡Ωñ‡ΩÄ‡Ωº‡Ω£‡ºã‡Ω¶‡æ§‡æ±‡Ωº‡Ωë‡ºã‡Ωî bkol spyod pa) </h2>
<p>Three types of operators drive the system:</p>
<ul>
    <li><strong>Human</strong>: Chooses propositions, interprets insights, and guides conjectures.</li>
    <li><strong>Machine</strong>: Automates computations, checks consistency, and suggests hypotheses.</li>
    <li><strong>Hybrid</strong>: Human sets goals, machine executes reasoning steps.</li>
</ul>

<h2>4. Refinements (‡Ω£‡Ω∫‡ΩÇ‡Ω¶‡ºã‡Ωñ‡ΩÖ‡Ωº‡Ω¶ legs bcos) </h2>
<p>Ensuring correctness and progression:</p>
<ul>
    <li><strong>Infinite Thinking</strong>: Achieved via iteration <code>S‚Çô ‚Üí ‚àû</code>.</li>
    <li><strong>Finite Steps</strong>: Each step is discrete, <code>S‚Çô ‚Üí S‚Çô‚Çä‚ÇÅ</code>.</li>
    <li><strong>Operator-Driven</strong>: The direction of reasoning is controlled by <code>O</code>.</li>
</ul>

<p>The cycle repeats indefinitely, refining knowledge.</p>
<code>
    S‚ÇÄ ‚Üí S‚ÇÅ ‚Üí S‚ÇÇ ‚Üí ... ‚Üí S‚Çô ‚Üí S‚Çô‚Çä‚ÇÅ ‚Üí ...
</code>
<p>Where:</p>
<ul>
    <li><code>S‚Çô</code> is a finite reasoning step.</li>
    <li><code>S‚Çô‚Çä‚ÇÅ</code> builds upon <code>S‚Çô</code>, ensuring refinement.</li>
    <li><strong>Limit process</strong>: <code>lim (n ‚Üí ‚àû) S‚Çô</code> represents <strong>infinite reasoning</strong>.</li>
</ul>

<h2>5. Design Goals (‡Ωë‡Ωò‡Ω≤‡ΩÇ‡Ω¶‡ºã‡Ω°‡Ω¥‡Ω£ dmigs yul)</h2>
<ul>
    <li><strong>Runtime Languages</strong>: Handle computation and concurrency.</li>
    <li><strong>Higher Languages</strong>: Ensure theorem proving and soundness.</li>
    <li><strong>Infinite Thinking</strong>: Achieved via refinements cycles.</li>
    <li><strong>Operator-Driven</strong>: Collaboration between humans and machines.</li>
</ul>

    </section>
    <section>
        <hr>
    </section>
    <section>
        <p>Verified Lambda Interpreter and Concurrent Parallel Matrix Runtime.
           Joe, Bob, and Alice languages share the same Standard ML like BNF grammar.</p>
    </section>
    <section>
        <a name=Joe></a>
        <h3><a href="https://github.com/groupoid/joe">Joe</a></h3>
         <p><b style="sel">Joe</b> is a certified bytecode stack interpreter and Intel/ARM code compiler.</p>
         <P>[1] ‚Äî MinCaml<br>
            [2] ‚Äî CoqASM<br>
            [3] ‚Äî Verified LISP Interpreter<br>
            [4] ‚Äî Kind<br>
         </p>
        <figure><pre>
fun a (0, n) = n + 1
  | a (m, 0) = a (m - 1, 1)
  | a (m, n) = a (m - 1, a (m, n - 1))
        </pre></figure>
    </section>
    <section>
        <a name=Bob></a>
        <h3><a href="https://github.com/o83/n2o">Bob</a></h3>
         <p><b style="sel">Bob</b> is a parallel concurrent non-blocking
            zero-copy run-time with CAS cursors [4,5].</p>
         <P>[5] ‚Äî Kernel<br>
            [6] ‚Äî Pony<br>
            [7] ‚Äî Erlang<br></p>
        <figure><pre>
fun proc =
let val p0 = pub(0,8)
    val s1 = sub(0,p0)
    val s2 = sub(0,p0)
 in send(p0,11);
    send(p0,12);
    [ receive(s1);
      receive(s2);
      receive(s1);
      receive(s2)
    ]
    end
        </pre></figure>
    </section>
    <section>
        <a name=Alice></a>
        <h3><a href="https://tonpa.guru/stream/2023/2023-09-25%20Formal%20Tensor.htm">Alice</a></h3>
         <p><b style="sel">Alice</b> is a linear types calculus
            with partial fractions [6] for BLAS level 3 programming.</p>
         <P>[8] ‚Äî NumLin<br> </p>
   <figure><pre>
fun simpleConvolution (i n: int) (x0: float) (write w: vector float)
  : vector float
  = begin
      if n = i then result.emit(write),
      a = [w0,w1,w2] = w.get(0,3),
      b = [x0,x1,x2] = [ x0 | write.get(i,2) ],
      write.set(i, Dotp(a,b)),
      simpleConvolution((i + 1),n,x1,write,w)
    end
     </pre></figure>
    </section>
    <section>
        <hr>
    </section>
    <section>
        <p>Sound and Consistent Predicative Formal Languages.
           Henk, Per, Anders, Dan languages share the same Lean like BNF grammar.</p>
    </section>
    <section>
        <a name=Henk></a>
        <h3><a href="https://github.com/groupoid/henk">Henk</a></h3>
        <p><b style="sel">Henk</b> is a Pure Type System (PTS-91) in
             the style of Coquand/Huet Calculus of Inductive Constructions (CoC-88)
             with infinite numbere of universes. Henk also supports AUTOMATH syntax (AUT-68).</p>
        <p>
           AUT-68 ‚Äî AUTOMATH<br>
           CoC-88 ‚Äî Calculus of Constructions<br>
           PTS-91 ‚Äî Pure Type System (Œ†)<br>
        </p>

        <figure><pre>
def N := Œ† (A : U), (A ‚Üí A) ‚Üí A ‚Üí A
def zero : N := Œª (A : U) (S : A ‚Üí A) (Z : A), Z
def succ : N -> N := Œª (n : N) (A : U) (S : A ‚Üí A) (Z : A), S (n A S Z)
def plus (m n : N) : N := Œª (A : U) (S : A ‚Üí A) (Z : A), m A S (n A S Z)
def mult (m n : N) : N := Œª (A : U) (S : A ‚Üí A) (Z : A), m A (n A S) Z
def pow (m n : N) : N := Œª (A : U) (S : A ‚Üí A) (Z : A), n (A ‚Üí A) (m A) S Z
        </pre></figure>

    </section>
    <section>
        <a name=Per></a>
        <h3><a href="https://github.com/groupoid/per">Per</a></h3>
        <p><b style="sel">Per</b> is a Œ†Œ£ (MLTT-72) prover with Calculus of
           Inductive Constructions and idenitity types (MLTT-75). The natural
           extension of CoC to CIC was done by Frank Pfenning and Christine Paulin (IND-89).</p>
        <p>
           Mini-TT ‚Äî OCaml implementation<br>
           MLTT-72 ‚Äî Pi, Sigma<br>
           MLTT-75 ‚Äî Pi, Sigma, Id<br>
           MLTT-80 ‚Äî 0, 1, 2, W, Pi, Sigma, Id<br>
           PP-89 ‚Äî Inductively Defined Types<br>
           CIC-2015 ‚Äî Calculus of Inductive Constructiions<br>
        </p>
        <figure><pre>
def empty      : U := inductive { }
def L¬π (A : U) : U := inductive { nil | cons (head: A) (tail: L¬π A) }
def S¬π         : U := inductive { base | loop : Equ S¬π base base }

def quot (A: U) (R : A -> A -> U) : U
 := inductive { quotient (a: A)
              | identification (a b: A) (r: R a b)
              : Equ (quot A R) (quotient a) (quotient b)
              }
        </pre></figure>
    </section>
    <section>
        <a name=Anders></a>
        <h3><a href="https://github.com/groupoid/anders">Anders</a></h3>
        <p><b style="sel">Anders</b> is a Homotopy Type System (HTS-2013)
           with Strict Equality and Cubical Agda (CCHM-2016) primitives.</p>
        <p>
           HTS-2013 ‚Äî Homotopy Type System<br>
           BCH-2014 ‚Äî Cubical Sets<br>
           CCHM-2015 ‚Äî Cubical Type System<br>
           OP-2016 ‚Äî Topos Axioms<br>
           CHM-2017 ‚Äî Huber Equations<br>
           VMA-2017 ‚Äî Cubical Agda<br>
        </p>
        <figure><pre>
def idfun  (A : U) : A ‚Üí A := Œª (a : A), a
def idfun‚Ä≤ (A : U) : A ‚Üí A := transp (&lt;i> A) 0
def idfun‚Ä≥ (A : U) : A ‚Üí A := Œª (a : A), hcomp A 0 (Œª (i : I), []) a
def isFiberBundle (B: U) (p: B ‚Üí U) (F: U): U
 := Œ£ (v: U) (w: surjective v B), (Œ† (x: v), PathP (&lt;_>U) (p (w.1 x)) F)
def ~~ (X : U) (a x‚Ä≤ : X) : U := Path (‚Ñë X) (Œπ X a) (Œπ X x‚Ä≤)
def ùîª (X : U) (a : X) : U := Œ£ (x‚Ä≤ : X), ~~ X a x‚Ä≤
def unitDisc (X : U) (x : ‚Ñë X) : U := Œ£ (x‚Ä≤ : X), Path (‚Ñë X) x (Œπ X x‚Ä≤)
def starDisc (X : U) (x : X) : ùîª X x := (x, idp (‚Ñë X) (Œπ X x))
def T‚àû (A : U) : U := Œ£ (a : A), ùîª A a
def inf-prox-ap (X Y : U) (f : X ‚Üí Y) (x x‚Ä≤ : X) (p : ~~ X x x‚Ä≤)
  : ~~ Y (f x) (f x‚Ä≤) := &lt;i> ‚Ñë-app X Y f (p @ i)
def d (X Y : U) (f : X ‚Üí Y) (x : X) (Œµ : ùîª X x) : ùîª Y (f x)
 := (f Œµ.1, inf-prox-ap X Y f x Œµ.1 Œµ.2)
def T‚àû-map (X Y : U) (f : X ‚Üí Y) (œÑ : T‚àû X) : T‚àû Y
 := (f œÑ.1, d X Y f œÑ.1 œÑ.2)
def is-homogeneous (A : U)
 := Œ£ (e : A) (t : A ‚Üí equiv A A),
    Œ† (x : A), Path A ((t x).1 e) x
         </pre></figure>

    </section>
    <section>
        <a name=Daniel></a>
        <h3><a href="https://github.com/groupoid/dan">Dan</a></h3>
        <p><b style="sel">Dan</b> is a simplicial CCHM-based verification system with
           Simplicial, Simplex, Chain, Monoid, Category, Group primitives built into the type checker core.
           Dan is new Rzk/GAP replacement with Kan, Rezk and Segal simplicial
           modes for computable ‚àû-categories.
        </p>
        <p>
           R-HoTT ‚Äî Rezk Infinity Categories<br>
           Hopf-HoTT ‚Äî Hopf Fibrations, Stable Spherical Homotopy Groups<br>
        </p>
        <figure><pre>
def path_z2_category : Category
 := –ü (x y : Simplex),
      (f g h : Simplex),
      (z2 : Group(–ü (e a : Simplex), a¬≤ = e ‚ä¢ 1 (a | a¬≤ = e))),
      f ‚àò g = h
    ‚ä¢ 2 (x y | f g h | f ‚àò g = h)

def z3 : Group
 := –ü (e a : Simplex),
      a¬≥ = e
    ‚ä¢ 1 (a | a¬≥ = e)

def M√∂bius : Simplex
 := –ü (a b c : Simplex),
      (bc ac : Simplex), ab = bc ‚àò ac
    ‚ä¢ 2 (a b c | bc ac ab)
         </pre></figure>

    </section>
    <section>
        <a name=Jack></a>
        <h3><a href="https://github.com/groupoid/jack">Jack</a></h3>
        <p><b style="sel">Jack</b> is a Minimal Framework for Homotopy Groups of Spheres
           which encompasses unstable homotopy, stable homotopy (e.g., œÄ‚ÇÄ^S(S‚Å∞) = ‚Ñ§),
           and chromatic phenomena (e.g., H^*(RP^2), spectral sequences),
           inspired by Morava's chromatic vision.
        </p>

        <a name=Urs></a>
        <h3><a href="https://github.com/groupoid/urs">Urs</a></h3>
        <p><b style="sel">Jack</b> is a Framework for Supergeometry in Cohesive Topos.
           It features Hopf Fibrations, Suspensions, Truncations, Œ†, Œ£, Id, ‚Ñï, ‚Ñï‚àû.
           for topological or physical systems.</P>

        <a name=Julius></a>
        <h3><a href="https://github.com/groupoid/julius">Julius</a></h3>
        <p><b style="sel">Julius</b> is a type system for Dedekind Reals, Cuts and Real Analysis.
           It features ‚Ñù, ‚Ñö, ‚ä¢ (ùêø, ùëà) : ‚Ñù, where ùêø, ùëà : ‚Ñö ‚Üí Prop, ‚àÄ ùëû < ùëü ‚Üí ùêø(ùëû) ‚à® ùëà(ùëü).</P>

        <a name=Ernst></a>
        <h3><a href="https://github.com/groupoid/ernst">Ernst</a></h3>
	<p><b style="sel">Ernst</b> is a type system for  ZFC LEM theories.
            It features: ùëâ, Pow(ùê¥), ùë• ‚àà ùê¥, ùê¥ ‚äÜ ùêµ; LEM: ‚ä¢ ùëÉ ‚à® ¬¨ùëÉ for Classical Logic Support.</p>

        <a name=Paul></a>
        <h3><a href="https://github.com/groupoid/paul">Paul</a></h3>
	<p><b style="sel">Paul</b> is a type system for Forced Cardinals.
            It features: ‚ä¢ ùúÖ : Card, inaccessible(ùúÖ), measurable(ùúÖ), Force(ùëÉ, ùê∫) : ùëâ ‚Üí ùëâ, ùëù ‚ä© ùúô,
            Generic filter ùê∫ over a poset ùëÉ, yielding a new model ùëâ[ùê∫], allowing for
            adjoin reals and control cardinalities or axioms.</p>
    </section>
    <section>
        <H2>Total Verification of Mathematics</H2>

	<p><b>Axiomatic Extended Integrated Ordered System for Infinite Structures (AXIOSIS)</b>
           is a novel type theory engineered to mechanically verify all existing
           theorems across mathematics, from classical analysis to modern set
           theory and homotopy. Building on top of advanced frameworks:</p>

<p><ul>
<li><b>Henk Barendregt</b> Type Theory for Pure Dependent Lambda Calculus,</li>
<li><b>Per Martin-L√∂f</b> Type Theory for Fibrational setting and inductive types,</li>
<li><b>Anders M√∂rtberg</b> Type Theory for CCHM/CHM/HTS bootstrap,</li>
<li><b>Dan Kan</b> Simplicial HoTT,</li>
<li><b>Jack Morava</b> Type Theory for Chromatic Homotopy Theory and K-Theory,</li>
<li><b>Urs Schreiber</b> Type Theory for Equivariant Supergeometry,</li>
<li><b>Julius Dedekind</b> Type Theory for Reals,</li>
<li><b>Ernst Zermelo</b> Type Theory for ZFC with LEM, and</li>
<li><b>Paul Cohen</b> Type Theory for cardinals system incorporating large cardinals and forcing;</li></ul></p>

<p>this system synthesis unifies synthetic homotopy, stable homotopy spectra, cohesive geometry, real analysis,
and set-theoretic foundations into a single, computationally verifiable formalism. We demonstrate its
power through key theorems:</p>

<p><ul>
<li>Number Theory: Prime Number Theorem,</li>
<li>Fundamental Theorem of Calculus (Analysis),</li>
<li>Analysis: Lebesgue Dominated Convergence Theorem,</li>
<li>Topology: Poincar√© Conjecture (3D),</li>
<li>Algebra: Classification of Finite Simple Groups,</li>
<li>Set Theory: Independence of the Continuum Hypothesis (CH),</li>
<li>Category Theory: Adjoint Functor Theorem,</li>
<li>Homotopy Theory: Adams Conjecture (via K-theory),</li>
<li>Cohesive Homotopy Theory: Brouwer Fixed-Point Theorem,</li>
<li>Consistency of ZFC with Large Cardinals,</li>
<li>Fermat‚Äôs Last Theorem,</li>
<li>Large Cardinal Theorem: Martin‚Äôs Maximum;</li></ul>

<p>showcasing its ability to span algebraic, analytic, topological, and
foundational domains. AXIOSIS stands as a candidate for a universal mechanized mathematics platform,
rivaling systems like Cubical Type Theory while extending their scope.
AXIOSIS achieves a landmark synthesis, unifying synthetic and classical mathematics in a mechanically
verifiable framework. Its type formers‚Äîspanning simplicial ‚àû-categories, stable spectra, cohesive modalities,
reals, ZFC, large cardinals, and forcing ‚Äî cover all known mathematical domains as of 2025.</p>

        <a name=Mono></a>
        <h3>Monography as Introductory Course</h3>
        <ul><li>Published by Axiosis: <a href="https://axiosis.github.io/books/axio/axio.pdf">axiosis.github.io/books/axio/axio.pdf</a></li>
        <li>AXIO/AXIOSIS Github Organization: <a href="https://github.com/groupoid/">github.com/groupoid/</a></li></ul>
    </section>
    <section>
        <h3>LaTeX</h3>

<figure><pre>
$ cp *.ttf ~/.local/share/fonts
$ sudo apt install texlive-full
$ sudo fc-cache -f
$ fc-match Geometria
$ make
</pre></figure>

        <h3>Sole Copyright</h3>

        <p>Namdak Tonpa</p>

    <section>


</main>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });

        renderer.setSize(window.innerWidth, window.innerHeight);
        document.querySelector(".canvas-container").appendChild(renderer.domElement);

        const starGeometry = new THREE.BufferGeometry();
        const starCount = 1500;
        const starVertices = [];

        for (let i = 0; i < starCount; i++) {
            let x = (Math.random() - 0.5) * 1000;
            let y = (Math.random() - 0.5) * 1000;
            let z = (Math.random() - 0.5) * 1000;
            starVertices.push(x, y, z);
        }

        starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
        const starMaterial = new THREE.PointsMaterial({ color: 0xFFFFFF, size: 2 });
        const stars = new THREE.Points(starGeometry, starMaterial);
        scene.add(stars);
        camera.position.z = 300;

        function animate() {
            requestAnimationFrame(animate);
            stars.rotation.y += 0.001;
            renderer.render(scene, camera);
        }

        function onResize() {
            renderer.setSize(window.innerWidth, window.innerHeight);
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
        }

        window.addEventListener("resize", onResize);

        animate();
    </script>

</body>
</html>